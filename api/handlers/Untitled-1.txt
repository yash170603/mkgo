// api/api.go
package api

import (
	"fmt"
	"hospital/api/routes"
	"hospital/internal/config"
	"hospital/internal/database"

	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"
)

type Api struct {
	App *gin.Engine
}

func New(db *database.DB, cfg config.Config) *Api {
	r := gin.Default()

	// CORS config
	corsConfig := cors.Config{
		AllowOrigins: []string{
			"http://localhost:3000",
			"https://stackguard-staging.vercel.app",
			"https://dashboard.stackguard.io",
		},
		AllowMethods:     []string{"GET", "POST", "PUT", "DELETE"},
		AllowHeaders:     []string{"Origin", "Content-Type", "Accept", "Authorization"},
		AllowCredentials: true,
	}
	r.Use(cors.New(corsConfig))

	apiGroup := r.Group("/api")
	routes.RegisterAuth(apiGroup, cfg, db)
	routes.RegisterProtected(apiGroup, cfg, db) // Add protected routes

	return &Api{App: r}
}

func (a *Api) Run(port int) error {
	return a.App.Run(fmt.Sprintf(":%d", port))
}

// api/routes/routes.go
package routes

import (
	"hospital/api/handlers"
	"hospital/api/middleware"
	"hospital/internal/config"
	"hospital/internal/database"
	"hospital/internal/services"

	"github.com/gin-gonic/gin"
)

func RegisterAuth(apiGroup *gin.RouterGroup, cfg config.Config, db *database.DB) {
	authService := services.NewAuthService(db, cfg)
	authHandler := handlers.NewHandler(authService)

	authGroup := apiGroup.Group("/auth")
	{
		authGroup.POST("/login", authHandler.LoginHandler)
		authGroup.POST("/logout", authHandler.LogoutHandler)
		authGroup.GET("/me", middleware.AuthMiddleware(cfg), authHandler.GetCurrentUser)
	}
}

func RegisterProtected(apiGroup *gin.RouterGroup, cfg config.Config, db *database.DB) {
	authService := services.NewAuthService(db, cfg)
	handler := handlers.NewHandler(authService)

	// Protected routes that require authentication
	protected := apiGroup.Group("/")
	protected.Use(middleware.AuthMiddleware(cfg))
	{
		// Routes accessible by both receptionist and doctor
		protected.GET("/profile", handler.GetProfile)
		
		// Doctor-only routes
		doctorOnly := protected.Group("/doctor")
		doctorOnly.Use(middleware.RoleMiddleware("doctor"))
		{
			doctorOnly.GET("/patients", handler.GetPatients)
			doctorOnly.POST("/prescriptions", handler.CreatePrescription)
		}

		// Receptionist-only routes
		receptionistOnly := protected.Group("/receptionist")
		receptionistOnly.Use(middleware.RoleMiddleware("receptionist"))
		{
			receptionistOnly.POST("/appointments", handler.CreateAppointment)
			receptionistOnly.GET("/appointments", handler.GetAppointments)
		}

		// Admin routes (if needed later)
		adminOnly := protected.Group("/admin")
		adminOnly.Use(middleware.RoleMiddleware("admin"))
		{
			adminOnly.GET("/users", handler.GetAllUsers)
			adminOnly.POST("/users", handler.CreateUser)
		}
	}
}

// api/handlers/handlers.go
package handlers

import (
	"net/http"
	"hospital/internal/models"
	"hospital/internal/services"

	"github.com/gin-gonic/gin"
)

type Handler struct {
	authService services.AuthService
}

func NewHandler(authService services.AuthService) *Handler {
	return &Handler{
		authService: authService,
	}
}

type LoginRequest struct {
	Email    string `json:"email" binding:"required,email"`
	Password string `json:"password" binding:"required,min=6"`
}

type LoginResponse struct {
	Token string      `json:"token"`
	User  models.User `json:"user"`
}

func (h *Handler) LoginHandler(c *gin.Context) {
	var req LoginRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	token, user, err := h.authService.Login(req.Email, req.Password)
	if err != nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})
		return
	}

	c.JSON(http.StatusOK, LoginResponse{
		Token: token,
		User:  *user,
	})
}

func (h *Handler) LogoutHandler(c *gin.Context) {
	token := c.GetHeader("Authorization")
	if token == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "No token provided"})
		return
	}

	// Remove "Bearer " prefix if present
	if len(token) > 7 && token[:7] == "Bearer " {
		token = token[7:]
	}

	if err := h.authService.Logout(token); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to logout"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Successfully logged out"})
}

func (h *Handler) GetCurrentUser(c *gin.Context) {
	user, exists := c.Get("user")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not found"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"user": user})
}

func (h *Handler) GetProfile(c *gin.Context) {
	user, _ := c.Get("user")
	c.JSON(http.StatusOK, gin.H{"profile": user})
}

// Example protected route handlers
func (h *Handler) GetPatients(c *gin.Context) {
	// Only doctors can access this
	c.JSON(http.StatusOK, gin.H{"patients": []string{"Patient 1", "Patient 2"}})
}

func (h *Handler) CreatePrescription(c *gin.Context) {
	// Only doctors can create prescriptions
	c.JSON(http.StatusCreated, gin.H{"message": "Prescription created"})
}

func (h *Handler) CreateAppointment(c *gin.Context) {
	// Only receptionists can create appointments
	c.JSON(http.StatusCreated, gin.H{"message": "Appointment created"})
}

func (h *Handler) GetAppointments(c *gin.Context) {
	// Only receptionists can view appointments
	c.JSON(http.StatusOK, gin.H{"appointments": []string{"Appointment 1", "Appointment 2"}})
}

func (h *Handler) GetAllUsers(c *gin.Context) {
	// Only admins can view all users
	users, err := h.authService.GetAllUsers()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch users"})
		return
	}
	c.JSON(http.StatusOK, gin.H{"users": users})
}

func (h *Handler) CreateUser(c *gin.Context) {
	// Only admins can create users
	var user models.User
	if err := c.ShouldBindJSON(&user); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	createdUser, err := h.authService.CreateUser(&user)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create user"})
		return
	}

	c.JSON(http.StatusCreated, gin.H{"user": createdUser})
}

// api/middleware/auth.go
package middleware

import (
	"net/http"
	"strings"
	"hospital/internal/config"
	"hospital/internal/models"

	"github.com/gin-gonic/gin"
	"github.com/golang-jwt/jwt/v5"
)

type Claims struct {
	UserID string `json:"user_id"`
	Email  string `json:"email"`
	Role   string `json:"role"`
	jwt.RegisteredClaims
}

func AuthMiddleware(cfg config.Config) gin.HandlerFunc {
	return func(c *gin.Context) {
		authHeader := c.GetHeader("Authorization")
		if authHeader == "" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Authorization header required"})
			c.Abort()
			return
		}

		// Extract token from "Bearer <token>"
		tokenString := strings.TrimPrefix(authHeader, "Bearer ")
		if tokenString == authHeader {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid authorization header format"})
			c.Abort()
			return
		}

		// Parse and validate token
		token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
			return []byte(cfg.JWTSecret), nil
		})

		if err != nil || !token.Valid {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token"})
			c.Abort()
			return
		}

		claims, ok := token.Claims.(*Claims)
		if !ok {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token claims"})
			c.Abort()
			return
		}

		// Set user info in context
		user := models.User{
			Email: claims.Email,
			Role:  claims.Role,
		}
		c.Set("user", user)
		c.Set("user_id", claims.UserID)
		c.Set("user_role", claims.Role)

		c.Next()
	}
}

func RoleMiddleware(requiredRole string) gin.HandlerFunc {
	return func(c *gin.Context) {
		userRole, exists := c.Get("user_role")
		if !exists {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "User role not found"})
			c.Abort()
			return
		}

		if userRole != requiredRole {
			c.JSON(http.StatusForbidden, gin.H{"error": "Insufficient permissions"})
			c.Abort()
			return
		}

		c.Next()
	}
}

// Multiple roles middleware
func RolesMiddleware(requiredRoles ...string) gin.HandlerFunc {
	return func(c *gin.Context) {
		userRole, exists := c.Get("user_role")
		if !exists {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "User role not found"})
			c.Abort()
			return
		}

		roleStr, ok := userRole.(string)
		if !ok {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid user role"})
			c.Abort()
			return
		}

		// Check if user's role is in the list of required roles
		hasPermission := false
		for _, role := range requiredRoles {
			if roleStr == role {
				hasPermission = true
				break
			}
		}

		if !hasPermission {
			c.JSON(http.StatusForbidden, gin.H{"error": "Insufficient permissions"})
			c.Abort()
			return
		}

		c.Next()
	}
}

// internal/services/auth_service.go
package services

import (
	"errors"
	"time"
	"hospital/internal/config"
	"hospital/internal/database"
	"hospital/internal/models"

	"github.com/golang-jwt/jwt/v5"
	"github.com/google/uuid"
	"golang.org/x/crypto/bcrypt"
	"gorm.io/gorm"
)

type AuthService interface {
	Login(email, password string) (string, *models.User, error)
	Logout(token string) error
	GetAllUsers() ([]models.User, error)
	CreateUser(user *models.User) (*models.User, error)
	GetUserByID(id string) (*models.User, error)
}

type authService struct {
	db  *database.DB
	cfg config.Config
}

func NewAuthService(db *database.DB, cfg config.Config) AuthService {
	return &authService{
		db:  db,
		cfg: cfg,
	}
}

type Claims struct {
	UserID string `json:"user_id"`
	Email  string `json:"email"`
	Role   string `json:"role"`
	jwt.RegisteredClaims
}

func (s *authService) Login(email, password string) (string, *models.User, error) {
	var user models.User
	if err := s.db.DB.Where("email = ?", email).First(&user).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return "", nil, errors.New("user not found")
		}
		return "", nil, err
	}

	// Check password
	if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(password)); err != nil {
		return "", nil, errors.New("invalid password")
	}

	// Generate JWT token
	claims := Claims{
		UserID: user.ID.String(),
		Email:  user.Email,
		Role:   user.Role,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(time.Now().Add(24 * time.Hour)),
			IssuedAt:  jwt.NewNumericDate(time.Now()),
		},
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokenString, err := token.SignedString([]byte(s.cfg.JWTSecret))
	if err != nil {
		return "", nil, err
	}

	return tokenString, &user, nil
}

func (s *authService) Logout(token string) error {
	// In a real application, you might want to maintain a blacklist of tokens
	// For now, we'll just return nil as the token will expire naturally
	return nil
}

func (s *authService) GetAllUsers() ([]models.User, error) {
	var users []models.User
	if err := s.db.DB.Find(&users).Error; err != nil {
		return nil, err
	}
	return users, nil
}

func (s *authService) CreateUser(user *models.User) (*models.User, error) {
	// Hash password
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte("defaultPassword123"), bcrypt.DefaultCost)
	if err != nil {
		return nil, err
	}

	user.ID = uuid.New()
	user.PasswordHash = string(hashedPassword)

	if err := s.db.DB.Create(user).Error; err != nil {
		return nil, err
	}

	return user, nil
}

func (s *authService) GetUserByID(id string) (*models.User, error) {
	var user models.User
	if err := s.db.DB.Where("id = ?", id).First(&user).Error; err != nil {
		return nil, err
	}
	return &user, nil
}

// internal/models/user.go
package models

import (
	"github.com/google/uuid"
	"gorm.io/gorm"
)

type User struct {
	ID           uuid.UUID `gorm:"primaryKey;type:uuid;default:gen_random_uuid()" json:"id"`
	Name         string    `gorm:"not null" json:"name"`
	Email        string    `gorm:"uniqueIndex;not null" json:"email"`
	Role         string    `gorm:"type:text CHECK (role IN ('receptionist','doctor','admin'));not null" json:"role"`
	PasswordHash string    `gorm:"not null" json:"-"`
}

// BeforeCreate hook to generate UUID if not set
func (u *User) BeforeCreate(tx *gorm.DB) error {
	if u.ID == uuid.Nil {
		u.ID = uuid.New()
	}
	return nil
}

// internal/config/config.go
package config

type Config struct {
	JWTSecret    string
	DatabaseURL  string
	Port         int
	Environment  string
}

// Example usage in main.go
package main

import (
	"hospital/api"
	"hospital/internal/config"
	"hospital/internal/database"
	"hospital/internal/models"
	"log"
)

func main() {
	// Load configuration
	cfg := config.Config{
		JWTSecret:   "your-secret-key-here",
		DatabaseURL: "your-database-url",
		Port:        8080,
		Environment: "development",
	}

	// Initialize database
	db, err := database.New(cfg.DatabaseURL)
	if err != nil {
		log.Fatal("Failed to connect to database:", err)
	}

	// Auto-migrate models
	if err := db.DB.AutoMigrate(&models.User{}); err != nil {
		log.Fatal("Failed to migrate database:", err)
	}

	// Create API instance
	apiInstance := api.New(db, cfg)

	// Start server
	log.Printf("Server starting on port %d", cfg.Port)
	if err := apiInstance.Run(cfg.Port); err != nil {
		log.Fatal("Failed to start server:", err)
	}
}